<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>21cm</title>
  
  <subtitle>愿用三生烟火，换你一世迷离。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://21cm.js.org/"/>
  <updated>2018-05-30T09:56:04.086Z</updated>
  <id>https://21cm.js.org/</id>
  
  <author>
    <name>21cm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>this的四种用法</title>
    <link href="https://21cm.js.org/2018/05/30/js-this/"/>
    <id>https://21cm.js.org/2018/05/30/js-this/</id>
    <published>2018-05-30T02:00:00.000Z</published>
    <updated>2018-05-30T09:56:04.086Z</updated>
    
    <content type="html"><![CDATA[<ul><li>javascript中this的指向有4种情况:</li><li><p>1.作为普通函数调用: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 2.作为对象方法调用: ```this```指向该对象</span><br><span class="line">* 3.构造器调用: this指向构造器返回的对象</span><br><span class="line">* 4.``Function.prototype.call`` 和 ``Function.prototype.apply``调用: ``this``指向动态传入的对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 丢失的this</span><br><span class="line">* 例子:</span><br><span class="line">* ``document.getElementById``这个函数名字太长,可以使用一个短点的函数来代替,例如prototype.js做法:</span><br></pre></td></tr></table></figure></p><p> var getId = function (id) {<br> return document.getElementById(id);<br>}<br>getId(‘div1’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> * 注意: 使用下面的方式是错误的!!!!!!!</span><br><span class="line"> * ``var getId=document.getElementById;``   错误做法!!!</span><br><span class="line"> * 因为```document.getElementById```这个方法的实现需要使用this指针,this指针期望指向document对象,</span><br><span class="line"> * 而这种做法作为普通函数调用,this指向了全局对象,即window,所以会出错!!</span><br><span class="line">// 可以使用apply传入document来帮助修正this:</span><br></pre></td></tr></table></figure></li></ul><p>document.getElementById = (function (func) {<br>    return function () {<br>        return func.apply(document, arguments);<br>    }<br>})(document.getElementById);<br>var getId = document.getElementById;  //这样就不会再报错<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;javascript中this的指向有4种情况:&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.作为普通函数调用: &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="javascript设计模式" scheme="https://21cm.js.org/categories/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="this" scheme="https://21cm.js.org/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>call、apply用法和bind实现</title>
    <link href="https://21cm.js.org/2018/05/30/function.prototype.bind/"/>
    <id>https://21cm.js.org/2018/05/30/function.prototype.bind/</id>
    <published>2018-05-30T01:00:00.000Z</published>
    <updated>2018-05-30T08:46:04.006Z</updated>
    
    <content type="html"><![CDATA[<ul><li>function.prototype.call 和 function.prototype.apply 的作用:</li><li><ol><li>改变this指向</li></ol></li><li><ol start="2"><li>借用借他对象的方法</li></ol></li></ul><ul><li>function.prototype.bind 函数用于指定函数内部this的指向</li><li>实现原理:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function.prototype.bind = function () &#123;</span><br><span class="line">    var self = this;  //保存原函数</span><br><span class="line">    var args = [].slice.call(arguments);</span><br><span class="line">    var context = args.shift();</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var argsArr = [].slice.call(arguments);</span><br><span class="line">        return self.apply(context, args.concat(argsArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindTest = function (age, grade) &#123;</span><br><span class="line">    console.log(this.name);                 //21cm</span><br><span class="line">    console.log([age, grade]);              //22,95</span><br><span class="line">&#125;.bind(&#123;name: &apos;21cm&apos;&#125;, 22);</span><br><span class="line">bindTest(95.0);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;function.prototype.call 和 function.prototype.apply 的作用:&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;改变this指向&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;借用借他对象的方
      
    
    </summary>
    
      <category term="javascript设计模式" scheme="https://21cm.js.org/categories/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="call" scheme="https://21cm.js.org/tags/call/"/>
    
      <category term="apply" scheme="https://21cm.js.org/tags/apply/"/>
    
      <category term="bind" scheme="https://21cm.js.org/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>变量的作用域和闭包</title>
    <link href="https://21cm.js.org/2018/05/29/field&amp;&amp;closure/"/>
    <id>https://21cm.js.org/2018/05/29/field&amp;&amp;closure/</id>
    <published>2018-05-29T11:00:00.000Z</published>
    <updated>2018-05-30T01:38:36.056Z</updated>
    
    <content type="html"><![CDATA[<ul><li>什么是闭包?</li><li><p>闭包是一个函数,用于捕获作用域内的外部绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//  * @param FACTOR</span><br><span class="line">//  * @returns &#123;Function&#125;</span><br><span class="line">//factor是createScaleFunction函数内的变量,却能在该函数返回后仍然使用</span><br><span class="line">//它从高阶函数中return实现&quot;越狱&quot;</span><br><span class="line">function createScaleFunction(FACTOR) &#123;</span><br><span class="line">    var factor = FACTOR;</span><br><span class="line">    return function (array) &#123;</span><br><span class="line">        return array.map(function (item) &#123;</span><br><span class="line">            return item * factor;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var scale10 = createScaleFunction(10);</span><br><span class="line">console.log(scale10([1, 2, 3, 4, 5]));  //10, 20, 30, 40, 50</span><br><span class="line">var scale2 = createScaleFunction(2);</span><br><span class="line">console.log(scale2([1, 2, 3, 4, 5]));   //2,4,6,8,10</span><br></pre></td></tr></table></figure><p>// * @returns {Function}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//利用闭包封装私有数据</span><br><span class="line">//实现一个自增计数器</span><br><span class="line">function increment() &#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// console.log(counter);  //error,访问不到</span><br><span class="line">var counter = increment();</span><br><span class="line">console.log(counter()); //1</span><br><span class="line">console.log(counter()); //2</span><br><span class="line">console.log(counter()); //3</span><br></pre></td></tr></table></figure><p>// * 实现bind函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function.prototype.bind = function () &#123;</span><br><span class="line">    var args = [].slice.apply(arguments);</span><br><span class="line">    var context = args.shift();</span><br><span class="line">    var self = this;   //保存原函数</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var args2 = args.concat([].slice.apply(arguments));</span><br><span class="line">        return self.apply(context, args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var func = function (a, b, c, d) &#123;</span><br><span class="line">    console.log(this.name);        //21cm</span><br><span class="line">    console.log([a, b, c, d]);     //3,4,1,2</span><br><span class="line">&#125;.bind(&#123;name: &apos;21cm&apos;&#125;, 3, 4);</span><br><span class="line">func(1, 2);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;什么是闭包?&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包是一个函数,用于捕获作用域内的外部绑定。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="函数式编程" scheme="https://21cm.js.org/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="变量作用域" scheme="https://21cm.js.org/tags/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="https://21cm.js.org/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程之 Applicative编程</title>
    <link href="https://21cm.js.org/2018/05/29/applicative/"/>
    <id>https://21cm.js.org/2018/05/29/applicative/</id>
    <published>2018-05-29T10:10:00.000Z</published>
    <updated>2018-05-29T11:51:49.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Applicative编程-将函数作为参数传递给另外一个函数-并且调用它。"><a href="#Applicative编程-将函数作为参数传递给另外一个函数-并且调用它。" class="headerlink" title="Applicative编程: 将函数作为参数传递给另外一个函数,并且调用它。"></a>Applicative编程: 将函数作为参数传递给另外一个函数,并且调用它。</h3><p>最常见的有数组的 map、reduce、filter函数等。</p><ul><li>例一: 实现一个函数,查找出某个数组中所有数字,可能实现一个findNumber方法,<br>那如果后面又有查找字母、查找大于10的数字…这些需求呢? 难道每个需求都要添加一个函数?<br>可以使用高阶函数,将一个条件判断的函数当做参数传递到一个通用的find函数中!</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function find(array, pred/!*function*!/) &#123;</span><br><span class="line">   var result = [];</span><br><span class="line">   array.forEach(function (item, index) &#123;</span><br><span class="line">       if (pred(item)) &#123;</span><br><span class="line">           result.push(item);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   return result;</span><br><span class="line">   &#125;</span><br><span class="line">var result = find([1, 2, 3, 4, &apos;a&apos;, &apos;c&apos;, 5], function (item) &#123;</span><br><span class="line">       // return item &gt;= 0 &amp;&amp; item &lt;= 9;   //查找数字 1,2,3,4,5</span><br><span class="line">       return item &gt;= &apos;a&apos; &amp;&amp; item &lt;= &apos;c&apos;;   //查找字母 a,c</span><br><span class="line">   &#125;);</span><br><span class="line">console.log(result); 1,2,3,4</span><br></pre></td></tr></table></figure><ul><li>例一的代码还可以写成如下形式,通过返回函数来定制不同行为</li><li>@param pred</li><li>@returns {Function}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function find(pred) &#123;</span><br><span class="line">    return function (array) &#123;</span><br><span class="line">        var result = [];</span><br><span class="line">        array.forEach(function (item, index) &#123;</span><br><span class="line">            if (pred(item)) &#123;</span><br><span class="line">                result.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> // * 1.查找数组中的数字</span><br><span class="line">var findNumber = find(function (x) &#123;</span><br><span class="line">    return x &gt;= 0 &amp;&amp; x &lt;= 9</span><br><span class="line">&#125;);</span><br><span class="line">console.log(findNumber([1, 2, 3, &apos;a&apos;, &apos;v&apos;, &apos;b&apos;, 4, &apos;kkk&apos;, &apos;rrr&apos;])); //1,2,3,4</span><br><span class="line"></span><br><span class="line">//  * 2.查找数组中除数字外的元素</span><br><span class="line">var findNotNumber = find(function (x) &#123;</span><br><span class="line">    return !(x &gt;= 0 &amp;&amp; x &lt;= 9);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(findNotNumber([1, 2, 3, &apos;a&apos;, &apos;v&apos;, &apos;b&apos;, 4, &apos;kkk&apos;, &apos;rrr&apos;])); // a,v,b,kkk,rrr</span><br><span class="line"></span><br><span class="line">//  * 3.查找数组中的小写字母</span><br><span class="line"></span><br><span class="line">var findLowerCaseLetters = find(function (x) &#123;</span><br><span class="line">    return x &gt;= &apos;a&apos; &amp;&amp; x &lt;= &apos;z&apos;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(findLowerCaseLetters([1, 2, 3, &apos;a&apos;, &apos;v&apos;, &apos;b&apos;, 4]));  a,v,b</span><br></pre></td></tr></table></figure><ul><li>例二: 写一个函数,来判断传入的参数是不是某种类型的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var isType = function (Type) &#123;</span><br><span class="line">    return function (data) &#123;</span><br><span class="line">        return Object.prototype.toString.call(data) === &apos;[object &apos; + Type + &apos;]&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//  * 1.判断是不是Number类型数据</span><br><span class="line">var isNumber = isType(&apos;Number&apos;);</span><br><span class="line">console.log(isNumber(0)); //true</span><br><span class="line">//  * 2.判断数据是不是字符串类型</span><br><span class="line">var isString = isType(&apos;String&apos;); //true</span><br><span class="line">console.log(isString(&apos;123&apos;));   //true</span><br><span class="line">console.log(isString(123));     //false</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Applicative编程-将函数作为参数传递给另外一个函数-并且调用它。&quot;&gt;&lt;a href=&quot;#Applicative编程-将函数作为参数传递给另外一个函数-并且调用它。&quot; class=&quot;headerlink&quot; title=&quot;Applicative编程: 将函数
      
    
    </summary>
    
      <category term="函数式编程" scheme="https://21cm.js.org/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="函数式编程" scheme="https://21cm.js.org/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Applicative编程" scheme="https://21cm.js.org/tags/Applicative%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://21cm.js.org/2018/05/29/Functional-programming/"/>
    <id>https://21cm.js.org/2018/05/29/Functional-programming/</id>
    <published>2018-05-29T10:00:00.000Z</published>
    <updated>2018-05-29T10:37:37.930Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>函数式编程:<br>1.确定抽象,将其构建为函数。<br>2.利用已有的函数来构建更复杂的抽象。<br>3.通过将现有函数传递给其它函数来构建更复杂的抽象。</p></li><li><p>面向对象编程是将问题分解为多组”名词”或叫对象,而函数式编程是将问题分解为多组”动词”或叫方法</p></li><li><p>与面向对象编程类似,函数式编程通过”组合”或”黏结”其他函数来构建更大的函数。</p><ul><li><p>例一: 函数作为参数</p><pre><code>[&quot;hello&quot;,&quot;hi&quot;].forEach(function (item, i) {    console.log(item); // hello hi})</code></pre></li><li><p>例二: 返回函数的函数</p><pre><code>function splat(func) {    return function (array) {        return func.apply(null, array);    }}var result = (splat(function (x, y) {    return x + y;}))([1, 2]);console.log(result); //3</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数式编程:&lt;br&gt;1.确定抽象,将其构建为函数。&lt;br&gt;2.利用已有的函数来构建更复杂的抽象。&lt;br&gt;3.通过将现有函数传递给其它函数来构建更复杂的抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;面向对象编程是将问题分解为多组”名词”或叫对象,而函数式编程是将
      
    
    </summary>
    
      <category term="函数式编程" scheme="https://21cm.js.org/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="函数式编程" scheme="https://21cm.js.org/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端算法排序之两个栈实现队列</title>
    <link href="https://21cm.js.org/2018/05/29/Two-stacks/"/>
    <id>https://21cm.js.org/2018/05/29/Two-stacks/</id>
    <published>2018-05-29T05:00:00.000Z</published>
    <updated>2018-05-29T09:40:45.371Z</updated>
    
    <content type="html"><![CDATA[<ul><li>利用2个栈实现一个队列, 只需要实现先进先出的功能</li><li>@constructor</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var Stack = require(&apos;https://21cm.js.org/lib/stack&apos;);</span><br><span class="line">var Queue = function () &#123;</span><br><span class="line">    this.stack1 = new Stack();</span><br><span class="line">    this.stack2 = new Stack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue.prototype.enqueue = function (ele) &#123;</span><br><span class="line">    this.stack1.push(ele);   //入队操作都压入栈1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue.prototype.dequeue = function () &#123;</span><br><span class="line">    if (this.stack2.length()) &#123;  //栈2不空,直接pop</span><br><span class="line">        return this.stack2.pop();</span><br><span class="line">    &#125; else &#123;  //若第二个栈不空,则将第一个栈中的所有元素出栈并压入栈2,并pop一次</span><br><span class="line">        while (this.stack1.length()) &#123;</span><br><span class="line">            this.stack2.push(this.stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return this.stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var q = new Queue();</span><br><span class="line">q.enqueue(1);</span><br><span class="line">q.enqueue(2);</span><br><span class="line">q.enqueue(3);</span><br><span class="line"></span><br><span class="line">console.log(q.dequeue());</span><br><span class="line">console.log(q.dequeue());</span><br><span class="line">console.log(q.stack1);</span><br><span class="line">console.log(q.stack2);</span><br><span class="line"></span><br><span class="line">console.log(&apos;----------------------------&apos;);</span><br><span class="line"></span><br><span class="line">q.enqueue(4);</span><br><span class="line">q.enqueue(5);</span><br><span class="line">console.log(q.dequeue());</span><br><span class="line">console.log(q.stack1);</span><br><span class="line">console.log(q.stack2);</span><br><span class="line"></span><br><span class="line">console.log(&apos;----------------------------&apos;);</span><br><span class="line"></span><br><span class="line">console.log(q.dequeue());</span><br><span class="line">console.log(q.dequeue());</span><br><span class="line">console.log(q.stack1);</span><br><span class="line">console.log(q.stack2);</span><br><span class="line"></span><br><span class="line">console.log(&apos;----------------------------&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;利用2个栈实现一个队列, 只需要实现先进先出的功能&lt;/li&gt;
&lt;li&gt;@constructor&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端算法" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="多队列" scheme="https://21cm.js.org/tags/%E5%A4%9A%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端算法排序之判断回文数</title>
    <link href="https://21cm.js.org/2018/05/29/Palindrome/"/>
    <id>https://21cm.js.org/2018/05/29/Palindrome/</id>
    <published>2018-05-29T04:00:00.000Z</published>
    <updated>2018-05-29T08:04:20.437Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用栈来判断一个数是否为回文数</li><li>@param number</li><li>@returns {boolean}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Stack = require(&apos;https://21cm.js.org/lib/stack&apos;);</span><br><span class="line">var isPalindromic = function (number) &#123;</span><br><span class="line">    if (!number || number &lt; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof number !== &apos;number&apos;) &#123;</span><br><span class="line">        console.warn(&apos;expect a number!&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var stack = new Stack();</span><br><span class="line">    var str = number + &apos;&apos;;</span><br><span class="line">    for (var i = 0, l = str.length; i &lt; l; i++) &#123;</span><br><span class="line">        stack.push(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    var destStr = &apos;&apos;;</span><br><span class="line">    while (stack.length()) &#123;</span><br><span class="line">        destStr += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    if (destStr === str) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">console.log(isPalindromic(-125));</span><br><span class="line">console.log(isPalindromic(&apos;12321&apos;));</span><br><span class="line">console.log(isPalindromic(12321));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;使用栈来判断一个数是否为回文数&lt;/li&gt;
&lt;li&gt;@param number&lt;/li&gt;
&lt;li&gt;@returns {boolean}&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端算法" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="判断回文数" scheme="https://21cm.js.org/tags/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端算法排序之数制转换</title>
    <link href="https://21cm.js.org/2018/05/28/js-Number-System-Conversion/"/>
    <id>https://21cm.js.org/2018/05/28/js-Number-System-Conversion/</id>
    <published>2018-05-28T04:00:00.000Z</published>
    <updated>2018-05-29T08:04:26.357Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* 利用栈来做数制转换</span><br><span class="line">* @param number  待转换的数字,十进制数</span><br><span class="line">* @param base   要转换成的进制(10进制以内)</span><br><span class="line"></span><br><span class="line">var Stack = require(&apos;https://21cm.js.org/lib/stack&apos;);</span><br><span class="line">var numericalTransform = function (number, base) &#123;</span><br><span class="line">    if (typeof number !== &apos;number&apos; || typeof base !== &apos;number&apos;) &#123;</span><br><span class="line">        console.log(&apos;Parameter error!&apos;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    var stack = new Stack();</span><br><span class="line">    do &#123;</span><br><span class="line">        stack.push(number % base);</span><br><span class="line">        number = Math.floor(number / base);</span><br><span class="line">    &#125; while (number !== 0)</span><br><span class="line">    //依次出栈,得到结果</span><br><span class="line">    var result = &apos;&apos;;</span><br><span class="line">    while (stack.length()) &#123;</span><br><span class="line">        result += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(numericalTransform(231, 8));</span><br><span class="line">console.log(numericalTransform(65, 2));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端算法" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="数制转换" scheme="https://21cm.js.org/tags/%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>前端算法之排序</title>
    <link href="https://21cm.js.org/2018/05/28/js-sort/"/>
    <id>https://21cm.js.org/2018/05/28/js-sort/</id>
    <published>2018-05-28T02:00:00.000Z</published>
    <updated>2018-05-28T09:57:00.461Z</updated>
    
    <content type="html"><![CDATA[<ul><li>排序算法分析比较</li></ul><h4 id="1-快速排序（QuickSort）"><a href="#1-快速排序（QuickSort）" class="headerlink" title="1 快速排序（QuickSort）"></a>1 快速排序（QuickSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">快速排序是一个就地排序，分而治之，大规模递归的算法。从本质上来说，它是归并排序的就地版本。快速排序可以由下面四步组成。</span><br><span class="line"></span><br><span class="line">（1） 如果不多于1个数据，直接返回。</span><br><span class="line">（2） 一般选择序列最左边的值作为支点数据。</span><br><span class="line">（3） 将序列分成2部分，一部分都大于支点数据，另外一部分都小于支点数据。</span><br><span class="line">（4） 对两边利用递归排序数列。</span><br><span class="line"></span><br><span class="line">快速排序比大部分排序算法都要快。尽管我们可以在某些特殊的情况下写出比快速排序快的算法，但是就通常情况而言，没有比它更快的了。</span><br><span class="line">快速排序是递归的，对于内存非常有限的机器来说，它不是一个好的选择。</span><br></pre></td></tr></table></figure><h4 id="2-归并排序（MergeSort）"><a href="#2-归并排序（MergeSort）" class="headerlink" title="2 归并排序（MergeSort）"></a>2 归并排序（MergeSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">归并排序先分解要排序的序列，从1分成2，2分成4，依次分解，当分解到只有1个一组的时候，就可以排序这些分组，</span><br><span class="line">然后依次合并回原来的序列中，这样就可以排序所有数据。合并排序比堆排序稍微快一点，但是需要比堆排序多一倍的内存空间，</span><br><span class="line">因为它需要一个额外的数组。</span><br></pre></td></tr></table></figure><h4 id="3-堆排序（HeapSort）"><a href="#3-堆排序（HeapSort）" class="headerlink" title="3 堆排序（HeapSort）"></a>3 堆排序（HeapSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">堆排序适合于数据量非常大的场合（百万数据）。</span><br><span class="line"></span><br><span class="line">堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。</span><br><span class="line">比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。</span><br><span class="line"></span><br><span class="line">堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。</span><br><span class="line">接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。</span><br></pre></td></tr></table></figure><h4 id="4-Shell排序（ShellSort）"><a href="#4-Shell排序（ShellSort）" class="headerlink" title="4 Shell排序（ShellSort）"></a>4 Shell排序（ShellSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。</span><br><span class="line">平均效率是O(nlogn)。其中分组的合理性会对算法产生重要的影响。现在多用D.E.Knuth的分组方法。</span><br><span class="line"></span><br><span class="line">Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。</span><br><span class="line">但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。</span><br></pre></td></tr></table></figure><h4 id="5-插入排序（InsertSort）"><a href="#5-插入排序（InsertSort）" class="headerlink" title="5 插入排序（InsertSort）"></a>5 插入排序（InsertSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插入排序通过把序列中的值插入一个已经排序好的序列中，直到该序列的结束。插入排序是对冒泡排序的改进。它比冒泡排序快2倍。</span><br><span class="line">一般不用在数据大于1000的场合下使用插入排序，或者重复排序超过200数据项的序列。</span><br></pre></td></tr></table></figure><h4 id="6-冒泡排序（BubbleSort）"><a href="#6-冒泡排序（BubbleSort）" class="headerlink" title="6 冒泡排序（BubbleSort）"></a>6 冒泡排序（BubbleSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。它通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，</span><br><span class="line">较小的数据上升。它是O(n^2)的算法。</span><br></pre></td></tr></table></figure><h4 id="7-选择排序（SelectSort）"><a href="#7-选择排序（SelectSort）" class="headerlink" title="7 选择排序（SelectSort）"></a>7 选择排序（SelectSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这两种排序方法都是交换方法的排序算法，效率都是 O(n2)。在实际应用中处于和冒泡排序基本相同的地位。</span><br><span class="line">它们只是排序算法发展的初级阶段，在实际中使用较少。</span><br></pre></td></tr></table></figure><h4 id="8-基数排序（RadixSort）"><a href="#8-基数排序（RadixSort）" class="headerlink" title="8 基数排序（RadixSort）"></a>8 基数排序（RadixSort）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基数排序和通常的排序算法并不走同样的路线。它是一种比较新颖的算法，但是它只能用于整数的排序，</span><br><span class="line">如果我们要把同样的办法运用到浮点数上，我们必须了解浮点数的存储格式，并通过特殊的方式将浮点数映射到整数上，</span><br><span class="line">然后再映射回去，这是非常麻烦的事情，因此，它的使用同样也不多。而且，最重要的是，这样算法也需要较多的存储空间。</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th style="text-align:center">排序法</th><th style="text-align:center">平均时间</th><th style="text-align:center">最差情形</th><th style="text-align:center">稳定度</th><th style="text-align:center">额外空间</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">稳定</td><td style="text-align:center">O(1)</td><td style="text-align:center">效率最低,n很小时可以使用,一般不用</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(1)</td><td style="text-align:center">效率很低,n很小时可以使用,一般不用</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">稳定</td><td style="text-align:center">O(1)</td><td style="text-align:center">大部分已排序时比较好</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n的s次方)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(1)</td><td style="text-align:center">1&lt;s&lt;2</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">数据量很大时好,平均效率最高的算法</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">稳定</td><td style="text-align:center">O(1)</td><td style="text-align:center">数据量很大时好</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(1)</td><td style="text-align:center">数据量很大时好</td></tr></tbody></table><ul><li>冒泡排序: 最慢的排序算法,基本上用不着!!!</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line"></span><br><span class="line">var bubbleSort = function (data) &#123;</span><br><span class="line">    var l = data.length;</span><br><span class="line">    for (var i = 0; i &lt;= l - 1; i++) &#123;  //外层循环表示要进行length趟排序</span><br><span class="line">        //内层循环表示在每一趟中两两交换进行排序</span><br><span class="line">        for (var j = 1; j &lt;= l; j++) &#123;</span><br><span class="line">            if (data[j] &lt; data[j - 1]) &#123;</span><br><span class="line">                var tmp = data[j];</span><br><span class="line">                data[j] = data[j - 1];</span><br><span class="line">                data[j - 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data = generateTestData(20000);</span><br><span class="line"></span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line"></span><br><span class="line">var result = bubbleSort(data);</span><br><span class="line"></span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line"></span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><ul><li>选择排序</li><li>选择排序是先找到起始数组中最小的元素，将它交换到i=0；</li><li>然后寻找剩下元素中最小的元素，将它交换到i=1的位置…… 直到找到第二大的元素，将它交换到n-2的位置。</li><li>这时，整个数组的排序完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;)</span><br><span class="line">var selectionSort = function (data) &#123;</span><br><span class="line">    // var l = data.length;</span><br><span class="line">    // for (var i = 0; i &lt;= l - 2; i++) &#123;</span><br><span class="line">    //     for (var j = i + 1; j &lt;= l - 1; j++) &#123;</span><br><span class="line">    //         if (data[j] &lt; data[i]) &#123;</span><br><span class="line">    //             var tmp = data[i];</span><br><span class="line">    //             data[i] = data[j];</span><br><span class="line">    //             data[j] = tmp;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    var l = data.length,</span><br><span class="line">        min_index;</span><br><span class="line">    for (var i = 0; i &lt;= l - 2; i++) &#123;</span><br><span class="line">        min_index = i;</span><br><span class="line">        //在后面的部分中找到最小值得index</span><br><span class="line">        for (var j = i + 1; j &lt;= l - 1; j++) &#123;</span><br><span class="line">            if (data[j] &lt; data[min_index]) &#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将最小值交换到未排序部分的头部</span><br><span class="line">        var tmp = data[i];</span><br><span class="line">        data[i] = data[min_index];</span><br><span class="line">        data[min_index] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(100000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = selectionSort(data);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><ul><li>插入排序:将整个数据集看作两个部分,前面已排序的部分和后面未排序的部分。</li><li>每次从未排序的部分中选择第一个数,插入到前面已排序部分的合适位置。</li><li>速度很慢!一般在数据集不超过1000的情况下使用。。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line">var insertSort = function (data) &#123;</span><br><span class="line">    var l = data.length;</span><br><span class="line">    for (var i = 1; i &lt;= l; i++) &#123;</span><br><span class="line">        var j = i - 1;</span><br><span class="line">        while ((j &gt;= 0) &amp;&amp; (data[j] &lt; data[j - 1])) &#123;</span><br><span class="line">            //交换</span><br><span class="line">            var tmp = data[j];</span><br><span class="line">            data[j] = data[j - 1];</span><br><span class="line">            data[j - 1] = tmp;</span><br><span class="line">            j--;  //j--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(20000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = insertSort(data);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><ul><li>希尔排序</li><li>Shell Sorting依赖于间隔(step)的选取。</li><li>希尔排序的核心理念和插入排序不同,它会首先比较距离较远的元素,而非相邻元素。</li><li>使用这种方案可以使离正确位置很远的元素能够快速回到更合适的位置。</li><li>可以动态定义每次排序的间隔,但在应用中,通常会提前定义好间隔序列。</li><li>希尔排序可以和其他排序算法配合使用,本例使用插入排序。</li><li>分组间隔的合理性会对希尔排序的性能造成较大的影响!!!</li><li>希尔排序比冒泡排序平均快5倍,比插入排序大致快2倍,但是比快排、归并、堆排序慢的多!!!!</li><li>但是比较简单实现,通常适用于数据量在5000以下的场景。。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line">var shellSort = function (data, gaps /*array of numbers*/) &#123;</span><br><span class="line">    var l = data.length;</span><br><span class="line">    for (var k = 0; k &lt; gaps.length; k++) &#123;  //最外层循环取得每次的step</span><br><span class="line">        var step = gaps[k];</span><br><span class="line">        //内部使用插入排序算法!</span><br><span class="line">        for (var i = step; i &lt;= l; i += step) &#123;</span><br><span class="line">            var j = i - step;</span><br><span class="line">            while ((j &gt;= 0) &amp;&amp; (data[j] &lt; data[j - step])) &#123;</span><br><span class="line">                //交换</span><br><span class="line">                var tmp = data[j];</span><br><span class="line">                data[j] = data[j - step];</span><br><span class="line">                data[j - step] = tmp;</span><br><span class="line">                j -= step;  //j-step</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(50000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = shellSort(data, [10, 4, 1]);</span><br><span class="line">// var result = shellSort(data, [701, 301, 132, 57, 23, 10, 4, 1]);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><ul><li>快速排序: 快速排序通常被认为是高效，快速等特点是使用V8引擎的实现Array.prototype.sort()上有超过23个项目的数组。</li><li>对于少于23个项目，V8采用插入排序法。</li><li>快排是处理大数据集最快的算法之一。它是一种分而治之的算法,通过递归的方式将数据集依次分解为包含较小元素和包含</li><li>较大元素的不同子序列。不断重复这个步骤直至所有数据有序。</li><li>这个算法首先要在数据集中选择一个基准值(pivot),数据排序围绕基准值进行。</li><li>将列表中小于基准值的数据移动到一侧,将大于基准值的数据移动到另一侧。</li><li>快速排序非常适用于大数据集,处理小数据集反而性能下降。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line">function quickSort(data, l, r) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        if (l &lt; r) &#123;</span><br><span class="line">            //Swap(s[l], s[(l + r) / 2]); //如果以数组中间的数作为基准值,将中间的这个数和第一个数交换即可</span><br><span class="line">            var i = l, j = r,</span><br><span class="line">                pivot = data[l];  //以数组第一个数作为基准值来分区</span><br><span class="line">            while (i &lt; j) &#123;</span><br><span class="line">                // 从右向左找第一个小于x的数</span><br><span class="line">                while (i &lt; j &amp;&amp; data[j] &gt;= pivot) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &lt; j) &#123;</span><br><span class="line">                    data[i++] = data[j];</span><br><span class="line">                &#125;</span><br><span class="line">                // 从左向右找第一个大于等于x的数</span><br><span class="line">                while (i &lt; j &amp;&amp; data[i] &lt; pivot) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &lt; j) &#123;</span><br><span class="line">                    data[j--] = data[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            data[i] = pivot;  //将pivot放入正确位置</span><br><span class="line">            // 对左右两边递归调用</span><br><span class="line">            quickSort(data, l, i - 1);</span><br><span class="line">            quickSort(data, i + 1, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(20000000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = quickSort(data, 0, data.length - 1);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line"> * 交换两个数</span><br><span class="line">function swap(items, firstIndex, secondIndex) &#123;</span><br><span class="line">    var temp = items[firstIndex];</span><br><span class="line">    items[firstIndex] = items[secondIndex];</span><br><span class="line">    items[secondIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> * 分区操作: 以数组的中位数为基准值!</span><br><span class="line">function partition(items, left, right) &#123;</span><br><span class="line">    var pivot = items[Math.floor((right + left) / 2)],</span><br><span class="line">        i = left,</span><br><span class="line">        j = right;</span><br><span class="line">    while (i &lt;= j) &#123;</span><br><span class="line">        while (items[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (items[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt;= j) &#123;</span><br><span class="line">            swap(items, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> * 快速排序</span><br><span class="line">function quickSort(items, left, right) &#123;</span><br><span class="line">    var index;</span><br><span class="line">    if (items.length &gt; 1) &#123;</span><br><span class="line">        index = partition(items, left, right);</span><br><span class="line">        if (left &lt; index - 1) &#123;</span><br><span class="line">            quickSort(items, left, index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; right) &#123;</span><br><span class="line">            quickSort(items, index, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return items;</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(500000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = quickSort(data, 0, data.length - 1);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><h4 id="快速排序详解"><a href="#快速排序详解" class="headerlink" title="快速排序详解"></a>快速排序详解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，而且快速排序思想----分治法也确实实用!</span><br><span class="line">必须要熟练掌握快排,弄清原理后,能够默写出快排算法!!!</span><br></pre></td></tr></table></figure><p><code>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</code></p><p>该方法的基本思想是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1．先从数列中取出一个数作为基准数。</span><br><span class="line"></span><br><span class="line">2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</span><br><span class="line"></span><br><span class="line">3．再对左右区间重复第二步，直到各区间只有一个数。</span><br></pre></td></tr></table></figure></p><p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。<br>对快速排序作了进一步的说明：<code>挖坑填数</code>+<code>分治法</code>：</p><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">72</td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">88</td><td style="text-align:center">60</td><td style="text-align:center">42</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">48</td><td style="text-align:center">85</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以一个数组作为示例，取区间第一个数为基准数。</span><br><span class="line">初始时，i = 0;  j = 9;   X = a[i] = 72</span><br><span class="line"></span><br><span class="line">由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</span><br><span class="line"></span><br><span class="line">从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  </span><br><span class="line">这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。</span><br><span class="line">这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j--;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">48</td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">88</td><td style="text-align:center">60</td><td style="text-align:center">42</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">88</td><td style="text-align:center">85</td></tr></tbody></table><p>数组变为上述这样。 i = 3;   j = 7;   X=72</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">再重复上面的步骤，先从后向前找，再从前向后找。</span><br><span class="line"></span><br><span class="line">从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</span><br><span class="line"></span><br><span class="line">从i开始向后找，当i=5时，由于i==j退出。</span><br><span class="line"></span><br><span class="line">此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">48</td><td style="text-align:center">6</td><td style="text-align:center">57</td><td style="text-align:center">42</td><td style="text-align:center">60</td><td style="text-align:center">72</td><td style="text-align:center">83</td><td style="text-align:center">73</td><td style="text-align:center">88</td><td style="text-align:center">85</td></tr></tbody></table><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。</p><h4 id="对挖坑填数进行总结"><a href="#对挖坑填数进行总结" class="headerlink" title="对挖坑填数进行总结"></a>对挖坑填数进行总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</span><br><span class="line"></span><br><span class="line">2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</span><br><span class="line"></span><br><span class="line">3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</span><br><span class="line"></span><br><span class="line">4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</span><br></pre></td></tr></table></figure><p>照着这个总结很容易实现挖坑填数的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int AdjustArray(int s[], int l, int r) //返回调整后基准数的位置  </span><br><span class="line">&#123;  </span><br><span class="line">    int i = l, j = r;  </span><br><span class="line">    int x = s[l]; //s[l]即s[i]就是第一个坑  </span><br><span class="line">    while (i &lt; j)  </span><br><span class="line">    &#123;  // 从右向左找小于x的数来填s[i]  </span><br><span class="line">        while(i &lt; j &amp;&amp; s[j] &gt;= x)   </span><br><span class="line">            j--;    </span><br><span class="line">        if(i &lt; j)   </span><br><span class="line">        &#123;  </span><br><span class="line">            s[i] = s[j]; //将s[j]填到s[i]中，s[j]就形成了一个新的坑  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 从左向右找大于或等于x的数来填s[j]  </span><br><span class="line">        while(i &lt; j &amp;&amp; s[i] &lt; x)  </span><br><span class="line">            i++;    </span><br><span class="line">        if(i &lt; j)   </span><br><span class="line">        &#123;  </span><br><span class="line">            s[j] = s[i]; //将s[i]填到s[j]中，s[i]就形成了一个新的坑  </span><br><span class="line">            j--;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //退出时，i等于j。将x填到这个坑中。  </span><br><span class="line">    s[i] = x;  </span><br><span class="line">    return i;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再写分治法的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort1(int s[], int l, int r)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (l &lt; r)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[]  </span><br><span class="line">        quick_sort1(s, l, i - 1); // 递归调用   </span><br><span class="line">        quick_sort1(s, i + 1, r);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码显然不够简洁，对其组合整理下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int s[], int l, int r)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (l &lt; r)  </span><br><span class="line">    &#123;  </span><br><span class="line">        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换(以数组中间的数作为基准值!!)  </span><br><span class="line">        int i = l, j = r, x = s[l];  </span><br><span class="line">        while (i &lt; j)  </span><br><span class="line">        &#123;  </span><br><span class="line">            while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数  </span><br><span class="line">                j--;    </span><br><span class="line">            if(i &lt; j)   </span><br><span class="line">                s[i++] = s[j];  </span><br><span class="line">              </span><br><span class="line">            while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数  </span><br><span class="line">                i++;    </span><br><span class="line">            if(i &lt; j)   </span><br><span class="line">                s[j--] = s[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        s[i] = x;  </span><br><span class="line">        quick_sort(s, l, i - 1); // 递归调用   </span><br><span class="line">        quick_sort(s, i + 1, r);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>快速排序还有很多改进版本，如随机选择基准数，区间内数据较少时直接用另的方法排序以减小递归深度。</strong></p><p><code>注1，有的书上是以中间的数作为基准数的，要实现这个方便非常方便，直接将中间的数和第一个数进行交换就可以了。</code></p><ul><li>归并排序</li><li>如果我们要将一副扑克按照数字大小排序。此前已经有两个人分别将其中的一半排好顺序。</li><li>那么我们可以将这两堆扑克向上放好，假设小的牌在上面。此时，我们将看到牌堆中最上的两张牌。</li><li>我们取两张牌中小的那张取出放在手中。两个牌堆中又是两张牌暴露在最上面，继续取小的那张放在手中……</li><li>直到所有的牌都放入手中，那么整副牌就排好顺序了。这就是归并排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line"> * js数组方法实现merge非常简洁,但是效率不高,见通用版本的merge方法!!!</span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;</span><br><span class="line">        if (left[0] &lt; right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.concat(left).concat(right);</span><br><span class="line">&#125;</span><br><span class="line">function mergeSort(items) &#123;</span><br><span class="line">     * 此句为递归结束条件,绝对不能遗漏!!!!</span><br><span class="line">    if (items.length == 1) &#123;</span><br><span class="line">        return items;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(items.length / 2),</span><br><span class="line">        left = items.slice(0, middle),</span><br><span class="line">        right = items.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(300000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = mergeSort(data);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><ul><li>归并排序通用版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line">function merge(a1, a2) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var i = 0,</span><br><span class="line">        j = 0,</span><br><span class="line">        l1 = a1.length,</span><br><span class="line">        l2 = a2.length;</span><br><span class="line">    while (i &lt; l1 &amp;&amp; j &lt; l2) &#123;</span><br><span class="line">        if (a1[i] &lt; a2[j]) &#123;</span><br><span class="line">            result.push(a1[i++]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(a2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; l1) &#123;</span><br><span class="line">        for (; i &lt; l1; i++) &#123;</span><br><span class="line">            result.push(a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; l2) &#123;</span><br><span class="line">        for (; j &lt; l2; j++) &#123;</span><br><span class="line">            result.push(a2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function mergeSort(data) &#123;</span><br><span class="line">    /***</span><br><span class="line">     * 此句为递归结束条件,绝对不能遗漏!!!!</span><br><span class="line">     */</span><br><span class="line">    if (data.length === 1) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(data.length / 2);</span><br><span class="line">    var left = data.slice(0, middle),</span><br><span class="line">        right = data.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(3000000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = mergeSort(data);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</span><br></pre></td></tr></table></figure><p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，<br>取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//将有序数组a[]和b[]合并到c[]中  </span><br><span class="line">void MemeryArray(int a[], int n, int b[], int m, int c[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j, k;  </span><br><span class="line">    i = j = k = 0;  </span><br><span class="line">    while (i &lt; n &amp;&amp; j &lt; m)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (a[i] &lt; b[j])  </span><br><span class="line">            c[k++] = a[i++];  </span><br><span class="line">        else  </span><br><span class="line">            c[k++] = b[j++];   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    while (i &lt; n)  </span><br><span class="line">        c[k++] = a[i++];  </span><br><span class="line">  </span><br><span class="line">    while (j &lt; m)  </span><br><span class="line">        c[k++] = b[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出合并有序数列的效率是比较高的，可以达到O(n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，</span><br><span class="line">那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</span><br><span class="line"></span><br><span class="line">可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，</span><br><span class="line">然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将有二个有序数列a[first...mid]和a[mid...last]合并。  </span><br><span class="line">void mergearray(int a[], int first, int mid, int last, int temp[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i = first, j = mid + 1;  </span><br><span class="line">    int m = mid,   n = last;  </span><br><span class="line">    int k = 0;  </span><br><span class="line">      </span><br><span class="line">    while (i &lt;= m &amp;&amp; j &lt;= n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (a[i] &lt;= a[j])  </span><br><span class="line">            temp[k++] = a[i++];  </span><br><span class="line">        else  </span><br><span class="line">            temp[k++] = a[j++];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    while (i &lt;= m)  </span><br><span class="line">        temp[k++] = a[i++];  </span><br><span class="line">      </span><br><span class="line">    while (j &lt;= n)  </span><br><span class="line">        temp[k++] = a[j++];  </span><br><span class="line">      </span><br><span class="line">    for (i = 0; i &lt; k; i++)  </span><br><span class="line">        a[first + i] = temp[i];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void mergesort(int a[], int first, int last, int temp[])  </span><br><span class="line">&#123;  </span><br><span class="line">    if (first &lt; last)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int mid = (first + last) / 2;  </span><br><span class="line">        mergesort(a, first, mid, temp);    //左边有序  </span><br><span class="line">        mergesort(a, mid + 1, last, temp); //右边有序  </span><br><span class="line">        mergearray(a, first, mid, last, temp); //再将二个有序数列合并  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">bool MergeSort(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int *p = new int[n];  </span><br><span class="line">    if (p == NULL)  </span><br><span class="line">        return false;  </span><br><span class="line">    mergesort(a, 0, n - 1, p);  </span><br><span class="line">    delete[] p;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，</span><br><span class="line">时间复杂度可以记为O(N)，故一共为O(N*logN)。因为归并排序每次都是在相邻的数据中进行操作，</span><br><span class="line">所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</span><br></pre></td></tr></table></figure><ul><li>堆排序<br>1.堆<br>堆实际上是一棵完全二叉树，其任何一非叶节点满足性质：<br><code>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]或者Key[i]&gt;=Key[2i+1]&amp;&amp;key&gt;=key[2i+2]</code><br>即任何一非叶节点的关键字不大于或者不小于其左右孩子节点的关键字。<br>堆分为大顶堆和小顶堆，满足<code>Key[i]&gt;=Key[2i+1]&amp;&amp;key&gt;=key[2i+2]</code>称为大顶堆，<br>满足<code>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]</code>称为小顶堆。<br>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。<br>2.堆排序的思想<br>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。<br>其基本思想为(大顶堆)：<br>1)将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无须区；<br>2)将堆顶元素<code>R[1]</code>与最后一个元素<code>R[n]</code>交换，此时得到新的无序区<code>(R1,R2,......Rn-1)</code>和新的有序区<code>(Rn)</code>,<br>且满足<code>R[1,2...n-1]&lt;=R[n]</code>;<br>3)由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区<code>(R1,R2,......Rn-1)</code>调整为新堆，<br>然后再次将<code>R[1]</code>与无序区最后一个元素交换，得到新的无序区<code>(R1,R2....Rn-2)</code>和新的有序区<code>(Rn-1,Rn)</code>。<br>不断重复此过程直到有序区的元素个数为<code>n-1</code>，则整个排序过程完成。<br>操作过程如下：<br>1)初始化堆：将<code>R[1..n]</code>构造为堆；<br>2)将当前无序区的堆顶元素<code>R[1]</code>同该区间的最后一个记录交换，然后将新的无序区调整为新的堆。<br>因此对于堆排序，最重要的两个操作就是构造初始堆和调整堆，其实构造初始堆事实上也是调整堆的过程， 只不过构造初始堆是对所有的非叶节点都进行调整。</li><li>堆排序</li><li>堆排序适合于数据量非常大的场合（百万数据）。</li><li>堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。</li><li>比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。</li><li>堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。</li><li>接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。</li><li>若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。</li><li>如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</li><li>实现堆排序需要解决两个问题：<br>　　　　1.如何由一个无序序列建成一个堆？<br>　　　　2.如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var generateTestData = require(&apos;https://21cm.js.org/lib/TestDataGenerator&apos;);</span><br><span class="line">/*方法说明：调整堆,维护堆的性质</span><br><span class="line"> @param  arr 数组</span><br><span class="line"> @param  x   数组下标</span><br><span class="line"> @param  len 堆大小*/</span><br><span class="line">function adjustHeap(arr, x, len) &#123;</span><br><span class="line">    var l = 2 * x, r = 2 * x + 1, largest = x, temp;</span><br><span class="line">    if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    if (largest != x) &#123;</span><br><span class="line">        temp = arr[x];</span><br><span class="line">        arr[x] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">        adjustHeap(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>/*方法说明：堆排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function heapSort(array) &#123;</span><br><span class="line">    //建堆</span><br><span class="line">    var heapSize = array.length, temp;</span><br><span class="line">    for (var i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123;</span><br><span class="line">        adjustHeap(array, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    //堆排序</span><br><span class="line">    for (var j = heapSize - 1; j &gt;= 1; j--) &#123;</span><br><span class="line">        temp = array[0];</span><br><span class="line">        array[0] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">        adjustHeap(array, 0, --heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var data = generateTestData(20000);</span><br><span class="line">// console.log(data);</span><br><span class="line">var start = new Date().getTime();</span><br><span class="line">console.log(&apos;start sorting....&apos;);</span><br><span class="line">var result = heapSort(data);</span><br><span class="line">var end = new Date().getTime();</span><br><span class="line">console.log(&apos;耗时: &apos; + (end - start) + &apos; ms&apos;);</span><br><span class="line">// console.log(result);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;排序算法分析比较&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-快速排序（QuickSort）&quot;&gt;&lt;a href=&quot;#1-快速排序（QuickSort）&quot; class=&quot;headerlink&quot; title=&quot;1 快速排序（QuickSort）&quot;&gt;&lt;/a&gt;1 快速排序
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端算法" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="排序" scheme="https://21cm.js.org/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://21cm.js.org/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="https://21cm.js.org/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://21cm.js.org/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://21cm.js.org/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://21cm.js.org/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://21cm.js.org/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://21cm.js.org/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端算法之查找算法</title>
    <link href="https://21cm.js.org/2018/05/28/js-lookup/"/>
    <id>https://21cm.js.org/2018/05/28/js-lookup/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-05-27T17:05:07.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li>顺序查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 23, 45, 55, 44, 22, 33];</span><br><span class="line">function find(array, data) &#123;</span><br><span class="line">    var length = array.length;</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (data === array[i]) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i === length) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(find(arr, 2));   //1 </span><br><span class="line">console.log(find(arr, 33));  //14</span><br><span class="line">console.log(find(arr, 100)); //-1</span><br></pre></td></tr></table></figure><ul><li>二分法查找:适用于有序的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for (var m = 1; m &lt;= 5; m++) &#123;</span><br><span class="line">    arr.push(m);</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr);  //1,2,3,4,5</span><br><span class="line"></span><br><span class="line">function binarySearch(array, data) &#123;</span><br><span class="line">    var l = array.length;</span><br><span class="line">    var low = 0,</span><br><span class="line">        high = l - 1;</span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        var middle = Math.floor((low + high) / 2);</span><br><span class="line">        if (data &lt; array[middle]) &#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125; else if (data &gt; array[middle]) &#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(binarySearch(arr, 50));     //49</span><br><span class="line">console.log(binarySearch(arr, 33));     //32</span><br><span class="line">console.log(binarySearch(arr, 1));      //0</span><br><span class="line">console.log(binarySearch(arr, 100));    //99</span><br><span class="line">console.log(binarySearch(arr, 1000));   //-1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;顺序查找&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端算法" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="查找算法-线性查找" scheme="https://21cm.js.org/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/"/>
    
      <category term="查找算法-二分查找" scheme="https://21cm.js.org/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之斐波那契数列</title>
    <link href="https://21cm.js.org/2018/05/27/fibonacci/"/>
    <id>https://21cm.js.org/2018/05/27/fibonacci/</id>
    <published>2018-05-27T05:00:00.000Z</published>
    <updated>2018-05-27T16:15:22.222Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    function fibonacci(n) &#123;</span><br><span class="line">        //递归,速度慢的不行,n到50几乎就无法算出,可能栈溢出!!!</span><br><span class="line">//        if (n &lt;= 0) &#123;</span><br><span class="line">//            return 0;</span><br><span class="line">//        &#125;</span><br><span class="line">//</span><br><span class="line">//        if (n == 1) &#123;</span><br><span class="line">//            return 1;</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line"></span><br><span class="line">        if (n &lt;= 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        var n1 = 0, n2 = 1, result;</span><br><span class="line">        for (var i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            result = n1 + n2;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">  &#125;</span><br><span class="line">    console.log(fibonacci(200));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://21cm.js.org/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="fibonacci" scheme="https://21cm.js.org/tags/fibonacci/"/>
    
      <category term="斐波那契数列" scheme="https://21cm.js.org/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-循环建议</title>
    <link href="https://21cm.js.org/2018/05/27/js-unfor...in/"/>
    <id>https://21cm.js.org/2018/05/27/js-unfor...in/</id>
    <published>2018-05-27T04:10:00.000Z</published>
    <updated>2018-05-27T04:12:11.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不要对数组使用for…in循环"><a href="#不要对数组使用for…in循环" class="headerlink" title="不要对数组使用for…in循环!!!"></a>不要对数组使用for…in循环!!!</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var index in myArray) &#123; // 千万别这样做</span><br><span class="line">  console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这绝对是一个糟糕的选择，为什么呢？</p><ul><li>在这段代码中，赋给index的值不是实际的数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。</li><li>作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。</li><li>最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。</li></ul><p><code>简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;不要对数组使用for…in循环&quot;&gt;&lt;a href=&quot;#不要对数组使用for…in循环&quot; class=&quot;headerlink&quot; title=&quot;不要对数组使用for…in循环!!!&quot;&gt;&lt;/a&gt;不要对数组使用for…in循环!!!&lt;/h4&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-循环" scheme="https://21cm.js.org/tags/javascript-%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-严格模式</title>
    <link href="https://21cm.js.org/2018/05/27/js-strict/"/>
    <id>https://21cm.js.org/2018/05/27/js-strict/</id>
    <published>2018-05-27T04:00:00.000Z</published>
    <updated>2018-05-27T04:10:01.427Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h4><p>严格模式主要有以下限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">变量必须声明后再使用</span><br><span class="line"></span><br><span class="line">函数的参数不能有同名属性，否则报错</span><br><span class="line"></span><br><span class="line">不能使用with语句</span><br><span class="line"></span><br><span class="line">不能对只读属性赋值，否则报错</span><br><span class="line"></span><br><span class="line">不能使用前缀0表示八进制数，否则报错</span><br><span class="line"></span><br><span class="line">不能删除不可删除的属性，否则报错</span><br><span class="line"></span><br><span class="line">不能删除变量delete prop，会报错，只能删除属性delete global[prop]</span><br><span class="line"></span><br><span class="line">eval不会在它的外层作用域引入变量</span><br><span class="line"></span><br><span class="line">eval和arguments不能被重新赋值</span><br><span class="line"></span><br><span class="line">arguments不会自动反映函数参数的变化</span><br><span class="line"></span><br><span class="line">不能使用arguments.callee</span><br><span class="line"></span><br><span class="line">不能使用arguments.caller</span><br><span class="line"></span><br><span class="line">禁止this指向全局对象</span><br><span class="line"></span><br><span class="line">不能使用fn.caller和fn.arguments获取函数调用的堆栈</span><br><span class="line"></span><br><span class="line">增加了保留字（比如protected、static和interface）</span><br></pre></td></tr></table></figure></p><p>设立”严格模式”的目的，主要有以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</span><br><span class="line"></span><br><span class="line">消除代码运行的一些不安全之处，保证代码运行的安全；</span><br><span class="line"></span><br><span class="line">提高编译器效率，增加运行速度；</span><br><span class="line"></span><br><span class="line">为未来新版本的Javascript做好铺垫。</span><br></pre></td></tr></table></figure></p><p><code>注：经过测试IE6,7,8,9均不支持严格模式。</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;说说严格模式的限制&quot;&gt;&lt;a href=&quot;#说说严格模式的限制&quot; class=&quot;headerlink&quot; title=&quot;说说严格模式的限制&quot;&gt;&lt;/a&gt;说说严格模式的限制&lt;/h4&gt;&lt;p&gt;严格模式主要有以下限制：&lt;br&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-严格模式" scheme="https://21cm.js.org/tags/javascript-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-new操作符</title>
    <link href="https://21cm.js.org/2018/05/27/js-new/"/>
    <id>https://21cm.js.org/2018/05/27/js-new/</id>
    <published>2018-05-27T02:50:00.000Z</published>
    <updated>2018-05-27T04:08:01.384Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</span><br><span class="line"></span><br><span class="line">   2、属性和方法被加入到 this 引用的对象中。</span><br><span class="line"></span><br><span class="line">   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</span><br><span class="line"></span><br><span class="line">var obj  = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"></span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;new操作符具体干了什么呢&quot;&gt;&lt;a href=&quot;#new操作符具体干了什么呢&quot; class=&quot;headerlink&quot; title=&quot;new操作符具体干了什么呢?&quot;&gt;&lt;/a&gt;new操作符具体干了什么呢?&lt;/h4&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-new" scheme="https://21cm.js.org/tags/javascript-new/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-null和undefined的区别？</title>
    <link href="https://21cm.js.org/2018/05/27/js-null&amp;&amp;js-undefined/"/>
    <id>https://21cm.js.org/2018/05/27/js-null&amp;&amp;js-undefined/</id>
    <published>2018-05-27T02:40:00.000Z</published>
    <updated>2018-05-27T04:06:49.001Z</updated>
    
    <content type="html"><![CDATA[<h4 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h4><p>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当声明的变量还未被初始化时，变量的默认值为undefined。</span><br><span class="line"></span><br><span class="line">null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</span><br><span class="line"></span><br><span class="line">undefined表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。典型用法是：</span><br><span class="line"></span><br><span class="line">（1）变量被声明了，但没有赋值时，就等于undefined。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（3）对象没有赋值的属性，该属性的值为undefined。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（4）函数没有返回值时，默认返回undefined。</span><br></pre></td></tr></table></figure></p><p>null表示”没有对象”，即该处不应该有值。典型用法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） 作为函数的参数，表示该函数的参数不是对象。</span><br><span class="line"></span><br><span class="line">（2） 作为对象原型链的终点。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;null和undefined的区别？&quot;&gt;&lt;a href=&quot;#null和undefined的区别？&quot; class=&quot;headerlink&quot; title=&quot;null和undefined的区别？&quot;&gt;&lt;/a&gt;null和undefined的区别？&lt;/h4&gt;&lt;p&gt;null是一
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-null" scheme="https://21cm.js.org/tags/javascript-null/"/>
    
      <category term="javascript-undefined" scheme="https://21cm.js.org/tags/javascript-undefined/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-ready &amp;&amp; javascript-onload</title>
    <link href="https://21cm.js.org/2018/05/27/js-ready&amp;&amp;js-onload/"/>
    <id>https://21cm.js.org/2018/05/27/js-ready&amp;&amp;js-onload/</id>
    <published>2018-05-27T02:30:00.000Z</published>
    <updated>2018-05-27T04:05:15.807Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jquery中$(document).ready()的作用类似于传统JavaScript中的window.onload方法，</span><br><span class="line">不过与window.onload方法还是有区别的。</span><br></pre></td></tr></table></figure><h4 id="1-执行时间"><a href="#1-执行时间" class="headerlink" title="1.执行时间"></a>1.执行时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </span><br><span class="line">$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</span><br></pre></td></tr></table></figure><h4 id="2-编写个数不同"><a href="#2-编写个数不同" class="headerlink" title="2.编写个数不同"></a>2.编写个数不同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 </span><br><span class="line">$(document).ready()可以同时编写多个，并且都可以得到执行</span><br></pre></td></tr></table></figure><h4 id="3-简化写法-针对jquery"><a href="#3-简化写法-针对jquery" class="headerlink" title="3.简化写法(针对jquery)"></a>3.简化写法(针对jquery)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.onload没有简化写法 </span><br><span class="line">$(document).ready(function()&#123;&#125;)可以简写成$(function()&#123;&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-ready" scheme="https://21cm.js.org/tags/javascript-ready/"/>
    
      <category term="javascript-onload" scheme="https://21cm.js.org/tags/javascript-onload/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-attribute &amp;&amp; javascript-property</title>
    <link href="https://21cm.js.org/2018/05/27/js-attribute&amp;&amp;js-property/"/>
    <id>https://21cm.js.org/2018/05/27/js-attribute&amp;&amp;js-property/</id>
    <published>2018-05-27T02:10:00.000Z</published>
    <updated>2018-05-27T04:01:16.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="attribute和property的区别是什么？"><a href="#attribute和property的区别是什么？" class="headerlink" title="attribute和property的区别是什么？"></a>attribute和property的区别是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attribute是dom元素在文档中作为html标签拥有的属性；</span><br><span class="line">property就是dom元素在js中作为对象拥有的属性。</span><br></pre></td></tr></table></figure><p>所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于html的标准属性来说，attribute和property是同步的，是会自动更新的，</span><br><span class="line">但是对于自定义的属性来说，他们是不同步的.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;attribute和property的区别是什么？&quot;&gt;&lt;a href=&quot;#attribute和property的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;attribute和property的区别是什么？&quot;&gt;&lt;/a&gt;attribute和p
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-attribute" scheme="https://21cm.js.org/tags/javascript-attribute/"/>
    
      <category term="javascript-property" scheme="https://21cm.js.org/tags/javascript-property/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-XSS &amp;&amp;javascript-csrf</title>
    <link href="https://21cm.js.org/2018/05/27/js-xss&amp;&amp;ja-csrf/"/>
    <id>https://21cm.js.org/2018/05/27/js-xss&amp;&amp;ja-csrf/</id>
    <published>2018-05-27T02:00:00.000Z</published>
    <updated>2018-05-27T03:56:27.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="XSS原理及防范"><a href="#XSS原理及防范" class="headerlink" title="XSS原理及防范"></a>XSS原理及防范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。</span><br><span class="line">比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，</span><br><span class="line">当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</span><br><span class="line"></span><br><span class="line">XSS防范方法</span><br><span class="line">首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；</span><br><span class="line">其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。</span><br><span class="line">首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。</span><br><span class="line">其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。</span><br><span class="line">如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。</span><br><span class="line">尽量采用POST 而非GET 提交表单</span><br></pre></td></tr></table></figure><h4 id="XSS与CSRF有什么区别吗？"><a href="#XSS与CSRF有什么区别吗？" class="headerlink" title="XSS与CSRF有什么区别吗？"></a>XSS与CSRF有什么区别吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</span><br></pre></td></tr></table></figure><h5 id="要完成一次CSRF攻击，受害者必须依次完成两个步骤："><a href="#要完成一次CSRF攻击，受害者必须依次完成两个步骤：" class="headerlink" title="要完成一次CSRF攻击，受害者必须依次完成两个步骤："></a>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录受信任网站A，并在本地生成Cookie。</span><br><span class="line">在不登出A的情况下，访问危险网站B。</span><br></pre></td></tr></table></figure><h4 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务端的CSRF方式方法很多样，但总的思想都是一致的，就是</span><br><span class="line">1. 在客户端页面增加伪随机数。</span><br><span class="line">2. 通过验证码的方法</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;XSS原理及防范&quot;&gt;&lt;a href=&quot;#XSS原理及防范&quot; class=&quot;headerlink&quot; title=&quot;XSS原理及防范&quot;&gt;&lt;/a&gt;XSS原理及防范&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-xss" scheme="https://21cm.js.org/tags/javascript-xss/"/>
    
      <category term="javascript-csrf" scheme="https://21cm.js.org/tags/javascript-csrf/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-缓存</title>
    <link href="https://21cm.js.org/2018/05/27/js-cache/"/>
    <id>https://21cm.js.org/2018/05/27/js-cache/</id>
    <published>2018-05-27T01:00:00.000Z</published>
    <updated>2018-05-27T03:32:30.450Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浏览器缓存的优点有："><a href="#浏览器缓存的优点有：" class="headerlink" title="浏览器缓存的优点有："></a>浏览器缓存的优点有：</h4><ul><li>减少了冗余的数据传输，节省了网费</li><li>减少了服务器的负担，大大提升了网站的性能</li><li>加快了客户端加载网页的速度<br>在前端开发面试中，浏览器缓存是web性能优化面试题中很重要的一个知识点，从而说明浏览器缓存是提升web性能的一大利器，<br>但是浏览器缓存如果使用不当，也会产生很多问题，正所谓是，想说爱你，并不是很容易的事。</li></ul><h4 id="浏览器缓存的分类"><a href="#浏览器缓存的分类" class="headerlink" title="浏览器缓存的分类"></a>浏览器缓存的分类</h4><p>浏览器缓存主要有两类：<code>协商缓存</code>和<code>强缓存</code>。</p><p>浏览器在第一次请求发生后，再次请求时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，</span><br><span class="line">包括缓存的header信息，本次请求不会与服务器进行通信；</span><br><span class="line">如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息</span><br><span class="line">（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，</span><br><span class="line">若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；</span><br><span class="line">否则返回最新的资源内容。</span><br></pre></td></tr></table></figure></p><h4 id="强缓存-强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。"><a href="#强缓存-强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。" class="headerlink" title="强缓存: 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。"></a>强缓存: 强缓存是利用http的返回头中的<code>Expires</code>或者<code>Cache-Control</code>两个字段来控制的，用来表示资源的缓存时间。</h4><p><strong>Expires</strong><br>该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。<br>这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，<br>所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</p><p><strong>Cache-Control</strong><br>Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，<br>例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：</p><ul><li>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，<br>那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li><li>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li></ul><p><code>Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。</code></p><h4 id="协商缓存-协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，"><a href="#协商缓存-协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，" class="headerlink" title="协商缓存: 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，"></a>协商缓存: 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，</h4><p>从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，<br>即第一次请求的响应头带上某个字段（Last-Modified或者Etag），<br>则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），<br>若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p><p><strong>Last-Modified/If-Modify-Since</strong></p><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modified，Last-modified是一个时间标识该资源的最后修改时间，<br>例如Last-Modified: Thu,31 Dec 2037 23:59:59 GMT。</p><p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modified。<br>服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p><p>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modified。</p><p><strong>ETag/If-None-Match</strong></p><p>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。<br>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p><p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，<br>即使这个ETag跟之前的没有变化。</p><p><code>为什么要有Etag</code></p><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？<br>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，<br>这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><code>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</code></p><h4 id="代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作。到底该如何解决呢？"><a href="#代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作。到底该如何解决呢？" class="headerlink" title="代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作。到底该如何解决呢？"></a>代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作。到底该如何解决呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在资源请求的URL中增加一个参数，比如：JS/mian.js?ver=0.7.1。这个参数是一个版本号，每一次部署的时候变更一下，</span><br><span class="line">当这个参数变化的时候，强缓存都会失效并重新加载。这样一来，静态资源，部署以后就需要重新加载。这样就比较完美的解决了问题。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;浏览器缓存的优点有：&quot;&gt;&lt;a href=&quot;#浏览器缓存的优点有：&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的优点有：&quot;&gt;&lt;/a&gt;浏览器缓存的优点有：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;减少了冗余的数据传输，节省了网费&lt;/li&gt;
&lt;li&gt;减少了服务器
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-缓存" scheme="https://21cm.js.org/tags/javascript-%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点总结之javascript-性能优化</title>
    <link href="https://21cm.js.org/2018/05/27/js-optimization/"/>
    <id>https://21cm.js.org/2018/05/27/js-optimization/</id>
    <published>2018-05-27T00:00:00.000Z</published>
    <updated>2018-05-27T03:14:26.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-JavaScript-压缩和模块打包"><a href="#1-JavaScript-压缩和模块打包" class="headerlink" title="1. JavaScript 压缩和模块打包"></a>1. JavaScript 压缩和模块打包</h4><p>JavaScript 应用是以源码形式进行分发的，而源码解析的效率是要比字节码低的。对于一小段脚本来说，区别可以忽略不计。<br>但是对于更大型的应用，脚本的大小会对应用启动时间有着负面的影响。事实上，寄期望于使用 WebAssembly 而获得最大程度的改善，<br>其中之一就是可以得到更快的启动时间。<br>另一方面，模块打包则用于将不同脚本打包在一起并放进同一文件。更少的 HTTP 请求和单个文件解析都可以减少加载时间。<br>通常情况下，单独一种工具就可以处理打包和压缩。Webpack 就是其中之一。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function insert(i) &#123;</span><br><span class="line">    document.write(&quot;Sample &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; 30; ++i) &#123;</span><br><span class="line">    insert(i);</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">!function(r)&#123;function t(o)&#123;if(e[o])return e[o].exports;var n=e[o]=&#123;exports:&#123;&#125;,id:o,loaded:!1&#125;;return r[o].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var e=&#123;&#125;;return t.m=r,t.c=e,t.p=&quot;&quot;,t(0)&#125;([function(r,t)&#123;function e(r)&#123;document.write(&quot;Sample &quot;+r)&#125;for(var o=0;30&gt;o;++o)e(o)&#125;]);</span><br><span class="line">//# sourceMappingURL=bundle.min.js.map</span><br><span class="line">进一步打包</span><br><span class="line">你也可以使用 Webpack 打包 CSS 文件以及合并图片。这些特性都可以有助于改善启动时间。</span><br></pre></td></tr></table></figure></p><h4 id="2-按需加载资源"><a href="#2-按需加载资源" class="headerlink" title="2. 按需加载资源"></a>2. 按需加载资源</h4><p>资源（特别是图片）的按需加载或者说惰性加载，可以有助于你的 Web 应用在整体上获得更好的性能。<br>对于使用大量图片的页面来说惰性加载有着显著的三个好处：</p><ul><li>减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）</li><li>减少浏览器的内存使用率（更少的图片，更少的内存）</li><li>减少服务器端的负载<br>大体上的理念就是只在必要的时候才去加载图片或资源（如视频），比如在第一次被显示的时候，或者是在将要显示的时候对其进行加载。<br>由于这种方式跟你建站的方式密切相关，惰性加载的解决方案通常需要借助其他库的插件或者扩展来实现。<br>举个例子，react-lazy-load 就是一个用于处理 React 惰性加载图片的插件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const MyComponent = () =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Scroll to load images.</span><br><span class="line">    &lt;div className=&quot;filler&quot; /&gt;</span><br><span class="line">    &lt;LazyLoad height=&#123;762&#125; offsetVertical=&#123;300&#125;&gt;</span><br><span class="line">      &lt;img src=&apos;http://apod.nasa.gov/apod/image/1502/HDR_MVMQ20Feb2015ouellet1024.jpg&apos; /&gt;</span><br><span class="line">    &lt;/LazyLoad&gt;</span><br><span class="line">    (...)</span><br><span class="line">一个非常好的实践范例就像 Goggle Images 的搜索工具一样。点击前面的链接并且滑动页面滚动条就可以看到效果了。</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-在使用-DOM-操作库时用上-array-ids"><a href="#3-在使用-DOM-操作库时用上-array-ids" class="headerlink" title="3. 在使用 DOM 操作库时用上 array-ids"></a>3. 在使用 DOM 操作库时用上 array-ids</h4><p>如果你正在使用 React，Ember，Angular 或者其他 DOM 操作库，使用 array-ids（或者 Angular 1.x 中的 track-by 特性）<br>非常有助于实现高性能，对于动态网页尤其如此。</p><p>此特性背后的主要概念就是尽可能多地重用已有的节点。Array ids 使得 DOM 操作引擎可以「知道」在什么时候某个节点可以<br>被映射到数组当中的某个元素。没有 array-ids 或者 track-by 的话，大部分库都会进行重新排序而摧毁已有的节点并重新创建新的。<br>这就非常损耗性能了。</p><h4 id="4-缓存"><a href="#4-缓存" class="headerlink" title="4. 缓存"></a>4. 缓存</h4><p>Caches 是用于存储那些被频繁存取的静态数据的组件，便于随后对于这个数据的请求可以更快地被响应，或者说请求方式更加高效。<br>由于 Web 应用是由很多可拆卸的部件组合而成，缓存就可以存在于架构中的很多部分。举例来说，缓存可以被放在动态内容服务器和客户端之间<br>，就可以避免公共请求以减少服务器的负载，与此同时改善响应时间。其他缓存可能被放置在代码里，以优化某些用于脚本存取的通用模式，<br>还有些缓存可能被放置在数据库或者是长运行进程之前。</p><p>简而言之，在 Web 应用中使用缓存是一种改善响应时间和减少 CPU 使用的绝佳方式。难点就在于搞清楚哪里才是在架构中存放缓存的地方。<br>再一次，答案就是性能分析：常见的瓶颈在哪里？数据或者结果可缓存吗？他们都太容易失效吗？这都是一些棘手的问题，需要从原理上来一点一点回答。</p><p>缓存的使用在 Web 环境中富有创造性。比如，basket.js 就是一个使用Local Storage 来缓存应用脚本的库。<br>所以你的 Web 应用在第二次运行脚本的时候就可以几乎瞬间加载了。</p><h4 id="5-启用-HTTP-2"><a href="#5-启用-HTTP-2" class="headerlink" title="5. 启用 HTTP/2"></a>5. 启用 HTTP/2</h4><p>越来越多的浏览器都开始支持 HTTP/2。这可能听起来没有必要，但是 HTTP/2 为同一服务器的并发连接问题带来了很多好处。<br>换句话说，如果有很多小型资源需要加载（如果你打包过的话就没有必要了），在延迟和性能方面 HTTP/2 秒杀 HTTP/1。</p><h4 id="6-应用性能分析"><a href="#6-应用性能分析" class="headerlink" title="6. 应用性能分析"></a>6. 应用性能分析</h4><p>性能分析是优化任何应用程序时的重要一步。就像介绍中所提到的那样，盲目尝试优化应用经常会导致效率的浪费，微不足道的收益和更差的可维护性。<br>执行性能分析是识别你的应用问题所在的一个重要步骤。</p><p>对于 Web 应用来说，延迟时间是最大的抱怨之一，所以你需要确保数据的加载和显示都尽可能得快。<br>Chrome 提供了非常棒的性能分析工具。特别是 Chrome Dev Tools 中的时间线和网络视图都对于定位延迟问题有着很大的帮助：</p><p>时间线视图可以帮忙找到运行时间较长的操作。</p><p>网络视图可以帮助识别出额外的由缓慢请求导致的延迟或对于某一端点的串行访问。</p><p>正确分析的话，内存则是另一块可能获得收益的部分。如果你正在运行着一个拥有很多虚拟元素的页面（庞大的动态表格）或者可交互式的元素（比如游戏），<br>内存优化可以获得更少的卡顿和更高的帧率。</p><p>CPU 性能分析也可以在 Chrome Dev Tools 中找到。找到性能损耗的中心可以让你有效率地达到优化的目标。</p><p>对后端的性能分析会更加困难。通常情况下，确认一个耗费较多时间的请求可以让你明确应该优先分析哪一个服务。<br>对于后端的分析工具来说，则取决于所构建的技术栈。</p><p>一个关于算法的注意事项</p><p>在大多数情况下，选择一个更优的算法，比围绕着小成本中心所实现的具体优化策略能够获得更大的收益。<br>在某种程度上，CPU 和内存分析应该可以帮你找到大的性能瓶颈。当这些瓶颈跟编码问题并不相关时，则是时候考虑考虑不同的算法了。</p><h4 id="7-使用负载均衡方案"><a href="#7-使用负载均衡方案" class="headerlink" title="7. 使用负载均衡方案"></a>7. 使用负载均衡方案</h4><p>把负载分配到不同的服务器（甚至于不同的地理区域）可以给你的用户提供更好的延迟时间，但是这条路还很漫长，特别是在处理很多的并发连接的时候。</p><p>负载均衡就跟使用某个 round-robin（循环）解决方案一样简单，可以基于一个 nginx 反向代理 ，或者基于一个成熟的分布式网络。</p><p>为了使负载均衡真正有效，动态内容和静态内容都应该被拆分成易于并发访问的。<br>换句话说，元素的串形访问会削弱负载均衡器以最佳形式进行分流的能力。与此同时，对于资源的并发访问可以改善启动时间。</p><p>虽然负载均衡可能会很复杂。对最终一致性算法不友好的数据模型，或者缓存都会让事情更加困难。<br>幸运的是，大多数应用对于已简化的数据集都只需要保证高层次的一致性即可。如果你的应用程序没有这样设计的话，就有必要重构一下了。</p><h4 id="8-为了更快的启动时间考虑一下同构-JavaScript"><a href="#8-为了更快的启动时间考虑一下同构-JavaScript" class="headerlink" title="8. 为了更快的启动时间考虑一下同构 JavaScript"></a>8. 为了更快的启动时间考虑一下同构 JavaScript</h4><p>改善 Web 应用程序观感的方式之一，就是减少启动时间或者减少首页渲染时间。<br>这对于新兴的单页面应用尤为重要，其需要在客户端执行大量任务。在客户端做更多事情通常就意味着，在第一次渲染被执行之前就需要下载更多的信息。<br>同构 JavaScript 可以解决这个问题：自从 JavaScript 可以同时运行在客户端和服务器端，这就让在服务器端来执行页面的首次渲染成为可能，<br>先把已渲染的页面发送出去然后再由客户端的脚本接管。这限制了所使用的后端（必须使用支持该特性的 JavaScript 框架），但却能获得更好的用户体验。<br>举例来说，React 就很适合于做这个，就像以下代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var React = require(&apos;react/addons&apos;);</span><br><span class="line">var ReactApp = React.createFactory(require(&apos;../components/ReactApp&apos;).ReactApp);</span><br><span class="line"></span><br><span class="line">module.exports = function(app) &#123;</span><br><span class="line"></span><br><span class="line">    app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">        // React.renderToString takes your component</span><br><span class="line">        // and generates the markup</span><br><span class="line">        var reactHtml = React.renderToString(ReactApp(&#123;&#125;));</span><br><span class="line">        // Output html rendered by react</span><br><span class="line">        // console.log(myAppHtml);</span><br><span class="line">        res.render(&apos;index.ejs&apos;, &#123;reactOutput: reactHtml&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Meteor.js 对于客户端和服务器端的 JavaScript 混用有着非常棒的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (Meteor.isClient) &#123;</span><br><span class="line">  Template.hello.greeting = function () &#123;</span><br><span class="line">    return &quot;Welcome to myapp.&quot;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Template.hello.events(&#123;</span><br><span class="line">    &apos;click input&apos;: function () &#123;</span><br><span class="line">      // template data, if any, is available in &apos;this&apos;</span><br><span class="line">      if (typeof console !== &apos;undefined&apos;)</span><br><span class="line">        console.log(&quot;You pressed the button&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Meteor.isServer) &#123;</span><br><span class="line">  Meteor.startup(function () &#123;</span><br><span class="line">    // code to run on server at startup</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，为了支持服务器端渲染，需要像 meteor-ssr 这样的插件。</p><p>如果你有复杂的或者中等大小的应用需要支持同构部署，试试这个，你可能会感到惊讶的。</p><h4 id="9-使用索引加速数据库查询"><a href="#9-使用索引加速数据库查询" class="headerlink" title="9. 使用索引加速数据库查询"></a>9. 使用索引加速数据库查询</h4><p>如果你需要解决数据库查询耗费大量时间的问题（分析你的应用看看是否是这种情况！），是时候找出加速数据库的方法了。<br>每个数据库和数据模型都有自己的权衡。数据库优化在每一方面都是一个主题：数据模型，数据库类型，具体实现方案，等等。<br>提速可能不是那么的简单。但是这儿有个建议，可能可以对某些数据库有所帮助：索引。<br>索引是一个过程，即数据库所创建的快速访问数据结构，从内部映射到键（在关系数据库中的列），可以提高检索相关数据的速度。<br>大多数现代数据库都支持索引。索引并不是文档型数据库（比如 MongoDB）所独有的，也包括关系型数据库（比如PostgreSQL）。</p><p>为了使用索引来优化你的查询，你将需要研究一下应用程序的访问模式：什么是最常见的查询，在哪个键或列中执行搜索，等等。</p><h4 id="10-使用更快的转译方案"><a href="#10-使用更快的转译方案" class="headerlink" title="10. 使用更快的转译方案"></a>10. 使用更快的转译方案</h4><p>JavaScript 软件技术栈一如既往的复杂。而改善语言本身的需求则又增加了复杂度。<br>不幸地是，JavaScript 作为目标平台又会被用户的运行时所限制。尽管很多改进已经以 ECMAScript 2015（2016正在进行）的形式实现了，<br>但是通常情况下，对客户端代码来说又不可能依赖于这个版本。<br>这种趋势促使了一系列的转译器：用于处理 ECMAScript 2015 代码的工具和只使用 ECMAScript 5 结构实现其中所缺失的特性。<br>与此同时，模块绑定和压缩处理也已经被集成到这个生产过程中，被称为为发布而构建的代码版本。这些工具可以转化代码，<br>并且能够以有限的方式影响到最终代码的性能。</p><h4 id="11-避免或最小化-JavaScript-和-CSS-的使用而阻塞渲染"><a href="#11-避免或最小化-JavaScript-和-CSS-的使用而阻塞渲染" class="headerlink" title="11. 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染"></a>11. 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</h4><p>JavaScript 和 CSS 资源都会阻塞页面的渲染。通过采取某些的规则，你可以保证你的脚本和 CSS 被尽可能快速地处理，<br>以便于浏览器能够显示你的网站内容。</p><p>在 CSS 的情况下这是非常重要的，所有的 CSS 规则都不能与特定媒体直接相关，规则只用于处理你准备在页面上所显示内容的优先级。<br>这可以通过使用 CSS 媒体查询来实现。媒体查询告诉浏览器，哪些 CSS 样式表应用在某个特定的显示媒体上。<br>举个例子，用于打印的某些规则可以被赋予比用于屏幕显示更低的优先级。</p><p>媒体查询可以被设置成 标签属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;only screen and (max-device-width: 480px)&quot; href=&quot;mobile-device.css&quot; /&gt;</span><br><span class="line">轮到 JavaScript 了，关键就在于遵循某些用于内联 JavaScript 的规则（比如内联在 HTML 文件当中的代码）。内联 JavaScript 应该尽可能短，并将其放在不会阻塞页面剩余部分解析的地方。换句话说，被放在 HTML 树中间的内联 JavaScript 将会在这个地方阻塞解析器，并强制其等待直到脚本被执行完毕。如果在 HTML 文件中随意放了一些大的代码块或者很多小的代码块，对于性能来说这会成为性能杀手。内联可以有效减少额外对于某些特定脚本的网络请求。但是对于重复使用的脚本或者大的代码块来说，这个好处就可以忽略不计了。</span><br></pre></td></tr></table></figure></p><p>防止 JavaScript 阻塞解析器和渲染器的一种方法就是将 <code>&lt;script&gt;</code> 标签标记为异步的。<br>这限制了我们对于 DOM 的访问但是可以让浏览器不管脚本的执行状态而继续解析和渲染页面。<br>换句话说，为了获得最佳的启动时间，确保那些对于渲染不重要的脚本已经通过异步属性的方式标记成异步的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;async.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="12-用于未来的一个建议：使用-service-workers-流"><a href="#12-用于未来的一个建议：使用-service-workers-流" class="headerlink" title="12. 用于未来的一个建议：使用 service workers + 流"></a>12. 用于未来的一个建议：使用 service workers + 流</h4><p>Jake Archibald 最近的一篇博文详细描述了一种有趣的技术，可以用于加速渲染时间：将 service workers 和流结合起来。结果非常令人叹服：</p><p>不幸的是这个技术所需要的 APIs 都还不稳定，这也是为什么这是一种有趣的概念但现在还没有真正被应用的原因。<br>这个想法的主旨就是在网站和客户端之间放置一个 service worker。<br>这个 service worker 可以在获取缺失信息的同时缓存某些数据（比如 header 和一些不会经常改变的东西）。<br>缺失的内容就可以尽可能快速地流向被渲染的页面。</p><p><a href="https://www.youtube.com/watch?v=Cjo9iq8k-bc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Cjo9iq8k-bc</a></p><h4 id="13-图片编码优化"><a href="#13-图片编码优化" class="headerlink" title="13. 图片编码优化"></a>13. 图片编码优化</h4><p>PNGs 和 JPGs 在 Web 发布时都会使用次优的设置进行编码。通过改变编码器和它的设置，对于需要大量图片的网站来说可以获得有效的改善。<br>流行的解决方案包括 OptiPNG 和jpegtran。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-JavaScript-压缩和模块打包&quot;&gt;&lt;a href=&quot;#1-JavaScript-压缩和模块打包&quot; class=&quot;headerlink&quot; title=&quot;1. JavaScript 压缩和模块打包&quot;&gt;&lt;/a&gt;1. JavaScript 压缩和模块打包&lt;/h4
      
    
    </summary>
    
      <category term="前端" scheme="https://21cm.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://21cm.js.org/tags/javascript/"/>
    
      <category term="javascript-性能优化" scheme="https://21cm.js.org/tags/javascript-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
